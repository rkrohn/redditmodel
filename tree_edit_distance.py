import zss
from zss import Node, Operation


#op types, taken from library code
REMOVE = Operation.remove
INSERT = Operation.insert
UPDATE = Operation.update
MATCH = Operation.match


#distance function for structural-only edit distance - assume all node labels are equal
def struct_only_dist(a, b):
	return 0   
#end struct_only_dist

#distance function taking node labels into account - distance is 0 if labels are exactly equal, 1 otherwise
def label_equality_dist(a, b):
	if a.get_label() == b.get_label():
		return 0
	else:
		return 1
#end label_equality_dist

#distance function that ignores node labels, but takes node time into account
#if node times are within 30 minutes of each other, distance is 0
#otherwise, distance is 1
def time_dist(a, b):
	if abs(a.get_time() - b.get_time()) <= 30:
		return 0
	else:
		return 1
#end time_dist


#basic insert and removal cost functions - either operation is a cost of 1
def remove_cost(a):
	return 1
def insert_cost(a):
	return 1


#custom node class for comment trees, with required method to get list of children
class CommentNode(object):
	def __init__(self, label, time):
		self.label = label
		self.children = list()
		self.time = time

	def get_children(self):
		return self.children

	def get_label(self):
		return self.label

	def get_time(self):
		return self.time

    #append child to end of list of children
	def append_child(self, node):
		self.children.append(node)
		return self     #return self so we can chain add operations

    #insert a child to the front of the list of children
	def prepend_child(self, node):
		self.children.insert(0, node)
		return self     #return self so we can chain add operations
#end CommentNode


#function converts nested dictionary tree structure to CommentNode structure
#input format is sim_tree.simulate_comment_tree output format (also generated by functions_paper_model.convert_comment_tree)
#each input object has an id, time in minutes, and list of children objects
#input objects should be sorted by time within each children list
def build_tree(input_root):

	#create root node
	root = CommentNode(input_root['id'], input_root['time'])

	stack = [(root, input_root['children'])]		#processing stack, CommentNode and list of children

	while len(stack) != 0:
		node, children = stack.pop()	#get last node added to stack, and it's list of children

		#process children
		for child in children:
			child_node = CommentNode(child['id'], child['time'])
			node.append_child(child_node)		#add child node
			stack.append((child_node, child['children']))

	#return root of tree
	return root
#end build_tree


#given a CommentNode tree root, print the tree comment times
#uses DFS to print the tree structure
def print_tree(root):
	stack = [(root, 0)]     #node processing stack, node and level

	while len(stack) != 0:
		curr, level = stack.pop()  #get last node added to stack
		print("    " * level + "%.3f" % curr.get_time())   #print this comment time

		#append children in reverse time order so final output is sorted
		stack.extend([(child, level+1) for child in curr.get_children()][::-1])   
	print("") 
#end print_tree


#given two trees in dictionary format, compute the tree edit distance between them
#return a few different measures:
#	total tree edit distance, count of inserted/removed/updated comments
#	update count, number of comments updated
#	update time error, total time delta of all updated comments
#	insert count, number of comments inserted (added to sim tree)
#	insert time error, total time delta of all inserted comments
#	remove count, number of comments removed (deleted from sim tree)
#	remove time error, total time delta of all removed comments
#	match count, total number of node matches (for easy % correct calcs)
def compare_trees(sim_dict_tree, truth_dict_tree):
	#get CommentNode format of the trees
	sim = build_tree(sim_dict_tree)
	truth = build_tree(truth_dict_tree)

	#compute edit distance - for now the time-version
	dist, ops = zss.distance(sim, truth, CommentNode.get_children, insert_cost, remove_cost, time_dist, return_operations=True)

	#break down the ops to get different operation counts and time errors
	update_count = 0
	insert_count = 0
	remove_count = 0
	update_time = 0
	insert_time = 0
	remove_time = 0
	match_count = 0
	for op in ops:
		op_type, op_time_error, op_str = parse_op(op)
		#handle different types
		if op.type == REMOVE:
			remove_count += 1
			remove_time += op_time_error
		elif op.type == INSERT:
			insert_count += 1
			insert_time += op_time_error
		elif op.type == UPDATE:
			update_count += 1
			update_time += op_time_error
		else:
			match_count += 1

	#return result
	return dist, update_count, update_time, insert_count, insert_time, remove_count, remove_time, match_count
#end compare_trees


#given an Operation object, return it's type, time error, and a string representation (contains type and affected comment times)
#time error computed as follows:
#	for remove operations (simulated an extra comment), return timestamp of that comment
#	for insert operations (simulation short a comment), return timestamp of inserted comment
#	for update operations (simulated comment timestamp is off), return absolute difference between simulated and actual timestamps
#	for match operations (comment times match exactly), return 0
#if op is an update, string includes include time shift
def parse_op(op):
	if op.type == REMOVE:
		return op.type, op.arg1.time, '<Operation Remove: ' + "%.3f" % op.arg1.time + '>'
	elif op.type == INSERT:
		return op.type, op.arg2.time, '<Operation Insert: ' + "%.3f" % op.arg2.time + '>'
	elif op.type == UPDATE:
		return op.type, abs(op.arg1.time-op.arg2.time), '<Operation Update: ' + "%.3f" % op.arg1.time + ' to ' + "%.3f" % op.arg2.time + ', shift ' + "%.3f" % (op.arg1.time-op.arg2.time) +  '>'
	else:
		return op.type, 0.0, '<Operation Match: ' + "%.3f" % op.arg1.time + '>'
#end parse_op

#legacy code - a few example usages, saving for posterity
def example():
	#define two test trees - same as in example above
	A = (
		CommentNode("f", 0)
			.append_child(CommentNode("a", 32)
				.append_child(CommentNode("h", 37))
				.append_child(CommentNode("c", 65)
					.append_child(CommentNode("l", 123))))
			.append_child(CommentNode("e", 50))
		)
	B = (
		CommentNode("f", 0)
			.append_child(CommentNode("a", 30)
				.append_child(CommentNode("d", 42))
				.append_child(CommentNode("c", 60)
					.append_child(CommentNode("b", 80))))
			.append_child(CommentNode("e", 47))
			.append_child(CommentNode("g", 126))
		)

	print_tree(A)
	print_tree(B)

	#compute distance between A and B, with custom node methods and structure-only method
	struct_dist = zss.distance(A, B, CommentNode.get_children, insert_cost, remove_cost, struct_only_dist)
	print("tree edit distance for A,B struct_only_dist =", struct_dist)
	#result should be 1, since B has one additional comment than A

	#get distance taking node label equality into account
	label_dist = zss.distance(A, B, CommentNode.get_children, insert_cost, remove_cost, label_equality_dist)
	print("tree edit distance for A,B label_equality_dist =", label_dist)
	#result should be 3, 1 for B's additional node and 2 from rename operations h->d and l->b

	#get distance taking node times into account, but ignoring labels
	time_dist = zss.distance(A, B, CommentNode.get_children, insert_cost, remove_cost, time_dist)
	print("tree edit distance for A,B time_dist =", time_dist)
	#result should be 2, 1 for B's additional node and 2 from the time difference between l and b
#end example
